# Глава 3. Создание приложение с использованием SlimPHP

В остальной части этой книги мы сосредоточимся на нашем веб-приложении: проверке погоды. Мы будем использовать [API MetaWeather](https://www.metaweather.com/api/), чтобы найти местоположение и получить там прогноз погоду. Когда мы найдем результаты, мы сохраним их в базе данных, чтобы будущие запросы получали кешированную версию результатов.

> Я выбрал API MetaWeather, потому что он бесплатный и не требует API-ключа. Существуют и другие API сервисов погоды, которые вы можете использовать бесплатно, но большинство из них требует, чтобы вы зарегистрировались и получили ключ.

Наше приложение предоставит очень простой API REST, который мы будем использовать для взаимодействия с сервисом. Мы создадим две конечные точки:

* `GET /locations/:location_id` — получает прогноз погоды из базы данных (если он есть) или делает запрос к MetaWeather, если нет кешированной версии.

* `DELETE /locations/:location_id` — удаляет кешированную версию результатов MetaWeather из базы данных. Следующий вызов `GET` для получения погоды по этому местоположению будет из API MetaWeather.

Прежде чем мы перейдем к логике приложения, давайте начнем с простого и установим [SlimPHP](https://www.slimframework.com/) и запустим его с помощью Docker.

## Установка фреймворка Slim

Slim — это очень маленький фреймворк для веб-разработки на PHP. В отличие от более сложных фреймворков, таких как [Laravel](https://laravel.com/) или [CakePHP](https://cakephp.org/), [Slim](https://www.slimframework.com/) включает не более, чем маршрутизатор, стек мидлваров и инжекторы зависимостей. Если вы знакомы с [фреймворком Node Express](https://expressjs.com/), Slim будет вам знаком, но даже если не знаете его, это такой небольшой фреймворк, который довольно легко понять. Вот почему я выбрал его для этой книги: я не хочу, чтобы фреймворк вас отвлекал, но вместе с этим я не хотел писать всё с нуля, так как основное внимание здесь уделяется Docker, а не нашему PHP-приложению.

Настройка Slim с Docker на самом деле требует меньше команд, чем при использовании локально установленной версии PHP. Мы будем использовать [Composer](https://getcomposer.org/), но благодаря Docker нам даже не нужно устанавливать его на нашей хост-машине.

Из командной строки создайте новый каталог для вашего PHP-приложения с интеграцией Docker:

{linenos=off, lang=sh}
~~~~~~~
$ mkdir weather-app
~~~~~~~

И перейдите в него:

{linenos=off, lang=sh}
~~~~~~~
$ cd weather-app
~~~~~~~

Теперь установите Slim, используя [официальный Docker-образ Composer](https://hub.docker.com/_/composer/):

{linenos=off, lang=sh}
~~~~~~~
$ docker run --rm -v $(pwd):/app composer:latest require slim/slim "^3.0"
~~~~~~~

Если вы посмотрите на каталог `weather-app/`, то увидите два файла (`composer.json` и `composer.lock`) и один каталог (`vendor/`):

{linenos=off, lang=sh}
~~~~~~~
$ ls
composer.json   composer.lock   vendor
~~~~~~~

### Что здесь происходит?

Наша команда `docker run` похожа на ту, которую мы использовали во второй главе, но мы использовали другой образ. Вместо образа PHP, который мы использовали для запуска скрипта hello.php, сейчас используем образ Composer. Давайте посмотрим, что изменилось.

* `composer:latest` — указывает образ, который мы используем для этого контейнера. Вы можете указать конкретную версию Composer, если вам нужно; просто проверьте список тегов образа, поддерживаемых в [Docker Hub](https://hub.docker.com/_/composer/).

* `require slim/slim "^3.0"` — это команда, которая на самом деле устанавливает Slim PHP в рабочий каталог контейнера. Поскольку этот рабочий каталог является томом из нашего каталога хоста, файлы установки Composer теперь присутствуют как на хост-машине, так и в контейнере.

На данный момент ваше приложение фактически ничего не делает, но Slim был установлен, и теперь у нас есть представление о том, как работает Composer с PHP в Docker.

## Определение конечных точек

Для того, чтобы вдохнуть жизнь нашему приложения, нам нужна пара конечных точек. Как упоминалось выше, Slim — это чуть больше, чем маршрутизатор, но на самом деле он заботится о большей части нашего приложения. Начнем с создания файла `index.php` с помощью пары определенных конечных точек, которые мы можем использовать на протяжении всего этого руководства.

{title="index.php", linenos=off, lang=php}
~~~~~~~
<?php

require 'vendor/autoload.php';

// Создать объект App
$app = new \Slim\App();

// Определение маршрутов
$app->get('/locations/{id}', function ($request, $response, $args) {
    return $response->withStatus(200)->write("Получено местоположение {$args['id']}.");
});

$app->delete('/locations/{id}', function ($request, $response, $args) {
    return $response->withStatus(200)->write("Удалено местоположение {$args['id']}.");
});

// Запуск приложения
$app->run();
~~~~~~~

### Что здесь происходит?

Этот единственный файл создает две конечные точки API, которые просто возвращают текст. Если вы не знакомы с системой маршрутизации Composer или Slim, вот что происходит:

* `require 'vendor/autoload.php';` — любой PHP-проект, который использует Composer, должен содержать файл Composer `autoload.php`. Поскольку наше новое приложение — всего лишь один файл, мы добавили это в первую очередь.

* `$app = new \Slim\App();` — создает новый экземпляр приложения Slim PHP. Slim может обрабатывать мидлвары и помогать также с инъекцией зависимостей, но пока мы просто используем его методы маршрутизации.

* `$app->get('/locations/{id}', function ($request, $response, $args) {...});` — это первая конечная точка обрабатывает GET-запросы к конечной точке, которой соответствует регулярному шаблону `/locations/{id}`, где id будет уникальный идентификатор местоположения. Мы подробно рассмотрим эту конечную точку и колбэк позже в руководстве.

* `$app->delete('/locations/{id}', function ($request, $response, $args) {...});` — эта вторая конечная точка обрабатывает DELETE-запросы конечной точке, которая соответствует регулярному шаблону `/locations/{id}`. Это позволит удалить данные о погоде в определенном местоположении, которое хранится в базе данных.

* `$app->run();` — наконец, эта строка запускает приложение Slim, позволяя использовать любые конечные точки, указанные выше. Обычно это последняя строка в любом проекте Slim.

## Запуск нашего приложения в первый раз

Теперь мы можем запустить наше приложение в контейнере Docker, чтобы попробовать его. Будет две конечных точек, которые на самом деле ничего не делают, но по крайней мере это позволит нам проверить, что мы находимся на верном пути, прежде чем мы продолжим расширять приложение. В терминале выполните:

{linenos=off, lang=sh}
~~~~~~~
$ docker run --rm -p 38000:80 -v $(pwd):/var/www/html php:apache
~~~~~~~

Теперь, если вы перейдете по URL-адресу http://localhost:38000/index.php/locations/1 в своем браузере, то увидите пустую страницу со следующим текстом:

`Получено местоположение 1.`

Вы только что успешно запустили свое первое веб-приложение на PHP в Docker!

### Что здесь происходит?

Команда `docker run`, которую мы использовали в этот раз, отличалась от той, которую мы использовали для запуска нашего скрипта hello.php и нашей команды `composer require ...`. Это объясняется тем, что на этот раз мы хотели получить последнюю версию PHP с [Apache](https://httpd.apache.org/), с тем чтобы мы могли обслуживать наше веб-приложение. Давайте рассмотрим новые части команды более подробно:

* `-p 38000:80` — здесь мы определяем [сопоставление портов](https://docs.docker.com/engine/reference/commandline/port/) между нашей контейнером и хост-системой. Эта команда говорит, что Docker должен сопоставить порт 80 на контейнере с портом 38000 на нашей хост-машине. Вы можете выбрать любой допустимый порт на вашем хосте, но возможно лучше будет использовать высокий (10000+) порт, потому что многие из более нижних зарезервированы для встроенных процессов на большинстве стандартных машин. Для контейнера вы *должны* использовать порт 80, потому что это порт, который предоставляет образ Docker, и на котором работает Apache.

* `-v $(pwd):/var/www/html` — на этот раз мы монтируем код с нашего хост-компьютера в каталог `/var/www/html` контейнера. Причина в том, что образ PHP Apache выполняет код из этого каталога. Это тонкая, но критическая разница между скриптами PHP, которые мы запускали раньше. Обязательно внимательно прочитайте [официальную документацию по документу PHP Docker](https://hub.docker.com/_/php/), чтобы избежать пропусков подобного.

* `php:apache` — этот образ является официальным тегом образа PHP Apache. Он объединяет PHP и Apache (популярный веб-сервер) в один контейнер, что позволяет быстро обслуживать ваш код для локальной разработки. Хотя мы не будем рассказывать об этом в этой книге, другим вариантом будет использование образа `php:fpm` и связанного контейнера `nginx`.

* Наконец, вы можете заметить, что на этот раз  после имени образа нет команды. Это может сбить с толку новых пользователей Docker, но по умолчанию большинство образов выполняют некоторую команду, даже если вы ее не укажете. В случае образа PHP Apache команда по умолчанию запускает [скрипт оболочки] (https://github.com/docker-library/php/blob/903540ea7918b5cabed6b32e81f8518f9e6f204f/7.1/apache/apache2-foreground), который запускает Apache. Этот скрипт именно то, что мы хотим, поэтому нет причин его менять.

На этом этапе ваш терминал покажет все входящие в Apache запросы, поэтому, когда вы загрузили первый URL-адрес, вы, вероятно, заметили что-то вроде:

{linenos=off, lang=sh}
~~~~~~~
172.17.0.1 - - [21/Aug/2017:18:35:33 +0000] "GET /index.php/locations/1 HTTP/1.1" 200 250 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.101 Safari/537.36"
~~~~~~~

Вы можете остановить и выйти из терминала, посылая сигнал "break" в терминал. На Mac это делается, удерживая `control` с нажатой `c`.

## Дополнительные параметры запуска Docker

### Работа в отдельном режиме

Другой вариант запуска вашего нового веб-приложения — запустить контейнер в «[отдельном режиме](https://docs.docker.com/engine/reference/run/#detached-vs-foreground)». Это означает, что вы не увидите вывод терминала из вашего контейнера. Это делается добавлением флага `-d` к нашей предыдущей команде:

{linenos=off, lang=sh}
~~~~~~~
$ docker run -d --rm -p 38000:80 -v $(pwd):/var/www/html php:apache
~~~~~~~

### Остановка контейнера

Сразу же после запуска контейнера в отдельном режиме ваш терминал отобразит полный идентификатор нового контейнера — что-то вроде `a403bf1018222a42ba ...` Если вы хотите остановить этот контейнер, вы можете указать Docker, используя команду `docker stop` с идентификатором контейнера. Например:

{linenos=off, lang=sh}
~~~~~~~
$ docker stop a403bf1018222a42ba
~~~~~~~

Поскольку ввод с клавиатуры полного идентификатора обременительно, Docker позволяет вам просто набирать первые три или более символов, сколько вы предпочитаете:

{linenos=off, lang=sh}
~~~~~~~
$ docker stop a40
~~~~~~~

### Именование контейнеров

Наконец, я рекомендую [давать названия вашим контейнерам](https://docs.docker.com/engine/reference/run/#container-identification). Мы сделаем это для многих последующих примеров в этой книге, так как гораздо легче запомнить контейнер по имени, чем случайно назначенный идентификатор, кроме этого, идентификаторы случайны, поэтому каждый раз, когда вы запускаете новую версию контейнера, он получает новый идентификатор. Имена могут выдаваться много раз, пока еще нет контейнера с тем же именем. Чтобы назвать наш новый контейнер приложения, мы могли бы его пересоздать с флагом `--name`, переданным в  него:

{linenos=off, lang=sh}
~~~~~~~
$ docker run -d --rm --name=weather-app -p 38000:80 -v $(pwd):/var/www/html php:apache
~~~~~~~

Есть много других опций, доступных при использовании команды [docker run](https://docs.docker.com/engine/reference/run/), поэтому вы можете прочитать документацию более подробно. Мы рассмотрим некоторые из этих опций в процессе разработки остальной части нашего приложения.

## Подключение к API MetaWeather

Следующим шагом в создании нашего API является извлечение данных из [API MetaWeather] (https://www.metaweather.com/api/). Это в основном проблема PHP, и выполнение в Docker не имеет большого значения, но давайте начнем с того, что все существующие контейнеры остановлены:

{linenos=off, lang=sh}
~~~~~~~
$ docker ps
~~~~~~~

Эта команда [перечислит спиоск всех запущенных контейнеров](https://docs.docker.com/engine/reference/commandline/ps/). Вы также можете увидеть остановленные контейнеры, добавив флаг `-a`.

Если какие-либо контейнеры запущены, используйте `docker stop <ID>`, чтобы остановить их, прежде чем продолжить.

### Добавление Guzzle

Хотя вы можете получать данные из API MetaWeather с помощью [встроенного в PHP адаптера cURL](http://php.net/manual/ru/book.curl.php), я предпочитаю [Guzzle](http://docs.guzzlephp.org/en/stable/), поскольку при его использовании для выполнения вызовов к API требуется меньше работы. Кроме того, это даст нам возможность установить новый пакет с помощью Composer. Откройте файл `composer.json`, который был автоматически создан, когда мы устанавливали Slim, и добавьте строку для Guzzle в блок `require`:

{linenos=off, lang=json}
~~~~~~~
{
    "require": {
        "slim/slim": "^3.0",
        "guzzlehttp/guzzle": "~6.0"
    }
}
~~~~~~~

Теперь в вашем терминале выполните:

{linenos=off, lang=sh}
~~~~~~~
$ docker run --rm -v $(pwd):/app composer:latest update
~~~~~~~

Контейнер установит новые пакеты и обновит ваш файл `composer.lock`. Во время этого процесса в терминале вы увидите подобный вывод:

{linenos=off, lang=sh}
~~~~~~~
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 3 installs, 0 updates, 0 removals
  - Installing guzzlehttp/promises (v1.3.1): Downloading (100%)
  - Installing guzzlehttp/psr7 (1.4.2): Downloading (100%)
  - Installing guzzlehttp/guzzle (6.3.0): Downloading (100%)
guzzlehttp/guzzle suggests installing psr/log (Required for using the Log middleware)
Writing lock file
Generating autoload files
~~~~~~~

Теперь Guzzle установлен и готов к использованию.

### Вызов API MetaWeather

Конечная точка, которую мы будем использовать, берет `woeid` ([«Where On Earth ID» (ID местоположения)](https://developer.yahoo.com/geo/geoplanet/guide/concepts.html)) и возвращает прогноз погоды в формате [JSON](https://www.json.org/). Первоначально наше приложение будет просто передавать запросы через MetaWeather и возвращать те же данные JSON, в котором они возвращаются. В следующей главе мы добавим кеширование базы данных. Вот наш обновленный файл `index.php`:

{title="index.php", linenos=off, lang=php}
~~~~~~~
<?php

require 'vendor/autoload.php';

// Создать новый контейнер с внедренным Guzzle
$container = new \Slim\Container([
    'http' => function () {
        return new GuzzleHttp\Client();
    }
]);

// Создать объект App
$app = new \Slim\App($container);

// Получить погоду по идентификатору местоположения
$app->get('/locations/{id}', function ($request, $response, $args) {

    // Получить погоду из MetaWeather
    $result = $this->http->get("https://www.metaweather.com/api/location/{$args['id']}")
        ->getBody()
        ->getContents();

    // Вернуть результаты в виде JSON
    return $response->withStatus(200)->withJson(json_decode($result));
});

// Конечная точка delete не изменилась
$app->delete('/locations/{id}', function ($request, $response, $args) {
    return $response->withStatus(200)->write("Удалена локация {$args['id']}.");
});

// Запуск приложения
$app->run();
~~~~~~~

### Что здесь происходит?

Мы сделали некоторые обновления — в основном, для конечной точки `get('/locations/{id}', ...)`. Давайте посмотрим, что здесь нового:

* `$container = new \Slim\Container([...]);` — если вы не знакомы с системой внедрения зависимости Slim, вы можете [прочитать про это здесь](https://www.slimframework.com/docs/concepts/di.html). Поскольку эта книга не касается инъекции зависимостей, я просто скажу, что это вводит Guzzle в приложение, поэтому мы можем использовать эту библиотеку на любом из наших маршрутов, вызывая `$this->http`. Это делает наш код более кратким и позволяет нам имитировать библиотеку, когда позже мы добавим тесты в приложение.

* `$result = $this->http->get("https://www.metaweather.com/api/location/{$args['id']}")...` — здесь мы делаем вызов к MetaWeather через Guzzle. Как вы можете видеть, мы просто передаем `locationId` с нашего маршрута Slim-приложения в конечную точку API, предоставленную MetaWeather. Мы также вызываем `getBody()` и `getContents()`, так как просто хотим получить ответ в виде строки, а не [потока] (http://docs.guzzlephp.org/en/stable/psr7.html#streams).

* `return $response->withStatus(200)->withJson(json_decode($result));` — наконец, мы отвечаем кодом ответа 200 и `withJson(...)`. Slim предоставляет этот метод для автоматической установки JSON-ответа, но поскольку ответ от MetaWeather вернулся в виде строки формата JSON, мы должны выполнить `json_decode` на нем, прежде чем перекодировать его в JSON.

### Тестирование

Наше приложение готово передать реальный идентификатор местоположения в API MetaWeather и вернуть некоторые данные. Сначала найдите идентификатор местоположения, используя [этот инструмент поиска WOEID](http://woeid.rosselliot.co.nz/). Я использую идентификатор своего родного города Чикаго для тестирования: `2379574`.

Теперь давайте снова запустим контейнер Docker:

{linenos=off, lang=sh}
~~~~~~~
$ docker run -d --rm --name=weather-app -p 38000:80 -v $(pwd):/var/www/html php:apache
~~~~~~~

И теперь посетите запущенное приложение в своем браузере по URL-адресу <http://localhost:38000/index.php/locations/2379574>. Вы должны получить ответ в JSON, который выглядит примерно так:

{linenos=off, lang=json}
~~~~~~~
{
  "consolidated_weather": [
    {
      "id": 5560109107249152,
      "weather_state_name": "Heavy Rain",
      "weather_state_abbr": "hr",
      "wind_direction_compass": "SSW",
      "created": "2017-08-21T17:23:20.408640Z",
      "applicable_date": "2017-08-21",
      "min_temp": 22.711666666666662,
      "max_temp": 29.093333333333334,
      "the_temp": 28.166666666666668,
      "wind_speed": 5.319549422227524,
      "wind_direction": 201.1261629987385,
      "air_pressure": 1012.975,
      "humidity": 74,
      "visibility": 14.841140240992603,
      "predictability": 77
    },
    ...
  ],
  "time": "2017-08-21T14:31:16.860660-05:00",
  "sun_rise": "2017-08-21T06:05:09.010298-05:00",
  "sun_set": "2017-08-21T19:42:46.959306-05:00",
  "timezone_name": "LMT",
  "parent": {
    "title": "Illinois",
    "location_type": "Region / State / Province",
    "woeid": 2347572,
    "latt_long": ""
  },
  "sources": [
    {
      "title": "BBC",
      "slug": "bbc",
      "url": "http://www.bbc.co.uk/weather/",
      "crawl_rate": 180
    },
    ...
  ],
  "title": "Chicago",
  "location_type": "City",
  "woeid": 2379574,
  "latt_long": "41.884151,-87.632408",
  "timezone": "US/Central"
}
~~~~~~~

Ваше приложение на PHP с интегрированным Docker теперь возвращает реальные данные из внешнего источника данных и будет обслуживаться сервером Apache, но вы, вероятно, заметите, что это не совсем самое быстрое приложение в мире (у меня было время загрузки страницы в 2,9 секунды!).

MetaWeather — это бесплатный сервис, который не ставит своей целью быть очень быстрым по всему миру. Чтобы исправить это, мы собираемся сохранять ответы от MetaWeather в нашей собственной базе данных MySQL и выдавать эти сохраненные ответы вместо того, чтобы делать новые запросы к API. Это значительно улучшит производительность, но также покажет нам, как добавить базу данных в приложение на PHP с помощью Docker.