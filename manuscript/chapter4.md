# Глава 4. Подключение к базе данных

Прежде чем мы сможем подключиться к базе данных, нам следует убедиться, что в нашем PHP-контейнере установлены все необходимые расширения. По умолчанию Docker-образ PHP из Docker Hub довольно лёгкий, поэтому он не включает много расширений PHP или пакетов Linux, которые могут вам понадобиться. Этот компромисс между маленькими по размеру и более гибкими образами — это то, что вам нужно выбирать на основе приоритетов вашего проекта, но поскольку мы знаем, что нам понадобится MySQL, давайте расширим базовый образ PHP необходимыми расширениями.

> Основные PHP-образы обычно являются хорошей отправной точкой, но я также начал держать несколько PHP-образов с более распространёнными расширениями на GitHub. Посмотрите [этот репозиторий для получения подробностей](https://github.com/shiphp/dockerfiles).

## Создание собственного Dockerfile

В корне вашего проекта `weather-app`, рядом с файлом `index.php`, создайте новый файл с названием `Dockerfile`. У файлов `Dockerfile` не имеют расширения и используются Docker для конфигурации и настройки образов. У всех образов на [Docker Hub](https://hub.docker.com/) есть файл с таким названием, и обычно вы можете найти их на GitHub. [Файлы `Dockerfile` для PHP находятся здесь](https://github.com/docker-library/php), но они могут быть немного запутанными, поскольку они строятся друг на друге. Наш `Dockerfile` будет гораздо проще:

#### Dockerfile

{title="Dockerfile", linenos=off, lang=sh}
~~~~~~~
FROM php:apache

RUN docker-php-source extract && docker-php-ext-install mysqli && docker-php-source delete
~~~~~~~

### Что здесь происходит?

Представленный выше `Dockerfile` содержат две строки:

* `FROM php:apache` — указывает Docker, с чего начать при создании образа. Вы можете начать с простого дистрибутива Linux (например, [Ubuntu](https://hub.docker.com/_/ubuntu/) или сверхлёгкий [Alpine](https://hub.docker.com/_/alpine /)), или вы можете расширить более конкретный контейнер, как в этом случае. Здесь мы расширяем образ `php:apache`, который мы использовали для запуска нашего контейнера раньше.

* `RUN docker-php-source extract...` — это строка добавляет расширения PHP, которые нам нужны. В нашем случае мы просто хотим использовать [функции mysqli](http://php.net/manual/ru/book.mysqli.php) для нашей базы данных. Поскольку это такое распространённое расширение, у образа PHP есть методы для его автоматического добавления, когда мы расширяем базовый образ этими строками.

> Ознакомьтесь с [официальной документацией Docker](https://docs.docker.com/engine/reference/builder/) для получения дополнительных опций для расширения существующих образов.

## Сборка образа

Мы соберём образ из файла `Dockerfile`, который мы создали выше:

{linenos=off, lang=sh}
~~~~~~~
$ docker build . -t shiphp/weather-app
~~~~~~~

Когда вы запустите эту команду, вы увидите кучу вывода, поскольку Docker создаёт ваш образ, заканчивая чем-то вроде:

{linenos=off, lang=sh}
~~~~~~~
Removing intermediate container 80b3f79714b2
Successfully built 8dc1f8c175a1
Successfully tagged shiphp/weather-app:latest
~~~~~~~

### Что здесь происходит

Команда [Docker build](https://docs.docker.com/engine/reference/commandline/build/) считывает файл `Dockerfile` и создаёт образ, который затем можно использовать для запуска контейнера. В этом случае мы передаём два параметра команде:

* `.` — символ «точка» позволяет Docker знать «контекст» нашей сборки — в данном случае это текущий каталог. Вы также можете использовать абсолютный путь, например `/Users/username/weather-app`, если вам известен точный путь вашего `Dockerfile`. Docker автоматически создаёт этот образ в рамках каталога, содержащего файл `Dockerfile`, поэтому убедитесь, что ваш файл `Dockerfile` находится в корне вашего проекта.

* `-t shiphp/weather-app` — флаг `-t` устанавливает «тег» для вашего образа. Этот тег позволит вам облегчить создание контейнера из образа или отправить образ в реестр, чтобы поделиться им с другими.

Вы можете просмотреть список всех Docker-образов на вашем локальном компьютере, запустив `$ docker images`. Когда вы запустите эту команду, вы должны увидеть что-то подобное в своём терминале:

{linenos=off, lang=sh}
~~~~~~~
REPOSITORY         TAG    IMAGE ID     CREATED        SIZE
shiphp/weather-app latest 8dc1f8c175a1 27 minutes ago 391MB
~~~~~~~

## Запуск контейнера с MySQL

Во введении я упомянул, что контейнеры Docker могут быть «связаны» через [возможность сети Docker](https://docs.docker.com/engine/userguide/networking/). Чтобы наше приложение PHP получало данные из нашей базы данных, нам нужно связать его с активным (работающим) контейнером базы данных. Давайте запустим новый контейнер MySQL, чтобы мы могли связать наше веб-приложение с ним:

{linenos=off, lang=sh}
~~~~~~~
$ docker run -d --rm --name weather-db -e MYSQL_USER=admin -e MYSQL_DATABASE=weather -e MYSQL_PASSWORD=p23l%v11p -e MYSQL_RANDOM_ROOT_PASSWORD=true mysql:5.7
~~~~~~~

### Что здесь происходит?

Когда вы запустите приведённую выше команду `docker run`, Docker получит последнюю версию [образа MySQL 5.7](https://hub.docker.com/_/mysql/) и запустит контейнер с именем weather-db. Как и PHP, MySQL имеет [перечисленные Docker-образы на Docker Hub](https://hub.docker.com/_/mysql/), и вы можете использовать их почти точно так же. Некоторые из вышеперечисленных флагов вы видите в первый раз, поэтому давайте внимательно разберём данную команду:

* `-d` — запускает контейнер в «отсоединённом» режиме, что означает, что вам не нужно будет подключать терминал к контейнеру.

* `--name weather-db` — именование нашего контейнера базы данных важно, потому что позволяет вам проще подключаться к именованному контейнеру. Мы также можем использовать это имя для подключения к базе данных MySQL из нашего PHP-приложения, как мы увидим позже.

* `-e MYSQL_USER=admin` — [образ MySQL](https://hub.docker.com/_/mysql/) содержит несколько опций `-e` (для установки переменной окружения). Первая опция задаёт имя пользователя для пользователя MySQL, которое мы будем использовать в нашем приложении PHP. Подробнее про опции, относящийся к окружению, можно узнать на [странице официального образа на Docker Hub](https://hub.docker.com/_/mysql/).

* `-e MYSQL_DATABASE=weather` — по умолчанию контейнер не будет создавать базу данных. Хотя вы можете создать её вручную, войдя в контейнер (эта возможность будет рассмотрена в следующем разделе), проще создать базу данных таким образом.

* `-e MYSQL_PASSWORD=p23l%v11p` — это устанавливает наш пароль базы данных на что-то, кроме значения по умолчанию. Несмотря на то, что это не огромный риск для безопасности, поскольку мы просто выполняем локальную разработку, вам стоит установить собственный надёжный пароль.

* `-e MYSQL_RANDOM_ROOT_PASSWORD=true` — ваш пароль пользователя root должен быть установлен на что-то случайное, так как вы все равно не будете входить в систему под пользователем root.

* `mysql:5.7` — как и с образом PHP, вы можете выбрать используемую версию MySQL. Здесь я решил использовать версию 5.7.

Как и с образом `php:apache`, команда образа по умолчанию в порядке, поэтому нам не нужно ничего добавлять после образа.

## Вход в работающий контейнер

На этом этапе мы хотим проверить, работает ли база данных в нашем новом контейнере, но как мы можем получить доступ к работающему контейнеру Docker? Мы будем использовать команду `docker exec` для входа в терминал в нашем новом контейнере, а затем, когда мы будем внутри, мы можем использовать [интерфейс командной строки MySQL](https://dev.mysql.com/doc/refman/5.7/en/mysql.html) для доступа к базе данных, которую мы создали.

Мы можем начать сессию bash в текущем контейнере базы данных, используя следующую команду:

{linenos=off, lang=sh}
~~~~~~~
$ docker exec -it weather-db bash
~~~~~~~

Вы должны увидеть строку, например `root@35c7ad5a574d:/#` (с идентификатором вашего контейнера) в вашем терминале, указывающую на то, что вы вошли в работающий контейнер. Внутри контейнера (не на хост-машине) выполните:

{linenos=off, lang=sh}
~~~~~~~
$ mysql --user=admin --password
Enter password:
~~~~~~~

Введите пароль, который вы выбрали для MySQL-контейнера, созданного командной выше (в этом примере это был `p23l%v11p`), и нажмите клавишу ввода. Вы увидите определённую информацию о MySQL:

{linenos=off, lang=sh}
~~~~~~~
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 10
Server version: 5.7.19 MySQL Community Server (GPL)

Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql>
~~~~~~~

Наконец, давайте просто проверим, что наша база данных была создана с помощью команды `show databases`:

{linenos=off, lang=sh}
~~~~~~~
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| weather            |
+--------------------+
2 rows in set (0.01 sec)
~~~~~~~

### Что здесь происходит?

В вышеприведённом разделе мы вошли в терминал работающего контейнера базы данных, затем мы вошли в MySQL через интерфейс командной строки и, наконец, посмотрели доступные нам базы данных. Поскольку вы, возможно, не знакомы со всеми этими командами, мы рассмотрим их одна за другим.

#### Docker Exec

* `docker exec` — это команда [Docker для выполнения команд](https://docs.docker.com/engine/reference/commandline/exec/) в запущенном контейнере. Как и команда Docker `run`, существует множество опций для команды `exec`, но мы просто рассмотрим основные моменты для этого примера.

* `-it` — флаг `-it` на самом деле представляет собой два флага, которые обычно используются вместе. Флаг `-i` запускает сеанс в «интерактивном» режиме, что означает, что потоки STDIN и STDOUT вашего терминала подключены к терминалу контейнера. Флаг `-t` присоединяет псевдотерминал к соединению. В [этом вопросе на Stack Overflow](https://stackoverflow.com/a/22287905/977192) немного больше объяснено, но достаточно сказать, что при выполнении bash-команд через `docker exec`, вероятно, вы захотите использовать флаги `-it`.

* `weather-db` — это имя (вы также можете использовать идентификатор) запущенного контейнера, в который мы хотим запустить нашу команду.

* `bash` — наконец, это команда, которую мы хотим запустить в контейнере. [bash](https://ru.wikipedia.org/wiki/Bash) — это командная оболочка, установленная в большинстве дистрибутивов Linux, которая позволяет нам запускать другие программы в контейнере. Если в вашем контейнере нет bash, вы можете [попробовать использовать *sh* вместо него](http://pubs.opengroup.org/onlinepubs/009695399/utilities/sh.html).

#### MySQL CLI

[CLI MySQL](https://dev.mysql.com/doc/refman/5.7/en/mysql.html) также предоставляет множество опций, но здесь мы использовали три:

* `mysql` — это команда, используемая для доступа к MySQL с терминала. Если вы используете MySQL на виртуальной машине или на вашей локальной машине, это то же самое.

* `--user=admin` — мы указываем имя пользователя, чтобы MySQL знал, что мы хотим получить доступ к базе данных как определённый пользователь, а не `root`.

* `--password` — флаг пароля указывает MySQL дать нам приглашение для ввода пароля. Вы также можете ввести пароль непосредственно в команду, но данный способ, как правило, менее безопасен.

#### Выход из MySQL и контейнера

Мы закончили с контейнером MySQL, так что давайте выйдем и остановим контейнер:

* Чтобы выйти из CLI MySQL, введите `\q` и нажмите клавишу ввода.

* Выйдите из контейнера, набрав `exit`, а затем нажмите клавишу ввода.

* Остановите контейнер, набрав `docker stop weather-db`, а затем снова нажмите клавишу ввода.

Весь вывод командной строки должен выглядеть примерно так, когда вы закончите:

{linenos=off, lang=sh}
~~~~~~~
mysql> \q
Bye
root@b01aff352dd7:/# exit
exit
$ docker stop weather-db
weather-db
~~~~~~~

Мы убедились, что наш контейнер MySQL работает, и мы можем войти в систему для доступа к базе данных, но как сохранить данные в контейнере? Что происходит, когда мы останавливаем этот контейнер? Постоянное хранение данных важно в реальных приложениях, поэтому в следующем разделе мы погрузимся в сохранение наших данных даже после того, как наш контейнер давно уже нет.

## Сохранение данных в контейнере нашей базы данных

До сих пор наш контейнер базы данных запускается и автоматически создаёт базу данных и пользователя. Это хорошо, но когда мы подключаем эту базу данных к нашему PHP-приложению, мы хотим убедиться, что таблицы и значения базы данных сохраняются даже после остановки нашего контейнера. В противном случае нам придётся пересоздавать базу данных каждый раз, когда перезагружается наш контейнер базы данных.

Лучший способ сохранить данные из контейнеров для локальной разработки — установить том. Мы видели, насколько эффективно это было для локальной разработки нашего PHP-кода, и процесс, которому мы следуем для монтирования наших данных базы данных, очень похож. Когда я работаю в проекте PHP, мне нравится монтировать тома базы данных из каталога проекта (в нашем случае, каталога `weather-app/`, который мы создали ранее), но вы можете смонтировать том из любой точки хост-системы.

> Важно отметить, что при монтировании томов с хост-компьютера Mac есть [негативные побочные эффекты с производительностью](https://docs.docker.com/docker-for-mac/osxfs-caching/). Это не должно быть проблемой в средах Linux, но я обнаружил, что при запуске смонтированных томов во многих связанных контейнерах, все может стать болезненно медленным. Docker предоставляет [определённые советы по настройки этого в macOS](https://docs.docker.com/docker-for-mac/osxfs-caching/).

Чтобы запустить контейнер MySQL с базой данных, сохранённой на вашей хост-системе, перейдите в новый каталог проекта `weather-app` и введите команду ниже:

{linenos=off, lang=sh}
~~~~~~~
$ docker run -d --rm --name weather-db -e MYSQL_USER=admin -e MYSQL_DATABASE=weather -e MYSQL_PASSWORD=p23l%v11p -e MYSQL_RANDOM_ROOT_PASSWORD=true -v $(pwd)/.data:/var/lib/mysql mysql:5.7
~~~~~~~

### Что здесь происходит?

Единственное, что мы добавили в эту команду `docker run` было `-v $(pwd)/.data:/var/lib/mysql`. Это монтирует том из нашего локального каталога в контейнер MySQL. Появится новый каталог (`.data/`), и при запуске контейнера базы данных появятся каталоги и файлы. Это файлы, которые MySQL использует для хранения ваших данных, и вы можете просматривать файлы, созданные из вашего терминала:

{linenos=off, lang=sh}
~~~~~~~
$ ls -a .data/
~~~~~~~

Вы должны увидеть перечисленные ниже файлы и папки:

{linenos=off, lang=text}
~~~~~~~
.                   ib_buffer_pool      private_key.pem
..                  ib_logfile0         public_key.pem
auto.cnf            ib_logfile1         server-cert.pem
ca-key.pem          ibdata1             server-key.pem
ca.pem              ibtmp1              sys
client-cert.pem     mysql               weather
client-key.pem      performance_schema
~~~~~~~

Не беспокойтесь о том, что означает каждый из них (хотя [вы можете прочитать внутренности MySQL, если вам интересно)(https://dev.mysql.com/doc/internals/en/)). На данный момент нам просто интересно, что MySQL теперь использует данные с нашего хост-компьютера в контейнере, что позволяет нам хранить данные базы данных даже после отключения контейнера.

> Обязательно добавьте каталог `.data` в файл `.gitignore`, чтобы ваша база данных не была добавлена в систему управления версиями.

## Создание таблицы базы данных

Поскольку этому приложению просто нужно кешировать результаты из API MetaWeather, в базе данных будет только одна таблица с тремя столбцами. Мы назовём таблицу `locations` и добавим столбцы `id`, `weather` и` last_updated`.

{width=100%}
![Диаграмма 3: база данных приложения прогноза погоды](images/diagram3.png)

Если контейнер MySQL не запущен, запустите его, используя команду выше (продублирована далее ниже), которая монтирует данные в томе:

{linenos=off, lang=sh}
~~~~~~~
$ docker run -d --rm --name weather-db -e MYSQL_USER=admin -e MYSQL_DATABASE=weather -e MYSQL_PASSWORD=p23l%v11p -e MYSQL_RANDOM_ROOT_PASSWORD=true -v $(pwd)/.data:/var/lib/mysql mysql:5.7
~~~~~~~

Войдите в контейнер и в CLI MySQL. На этот раз мы сделаем это в одно действие:

{linenos=off, lang=sh}
~~~~~~~
$ docker exec -it weather-db mysql --user=admin --password=p23l%v11p weather
~~~~~~~

Затем мы собираемся выполнить приведённую ниже SQL-команду для создания таблицы базы данных:

{linenos=off, lang=sh}
~~~~~~~
mysql> CREATE TABLE locations (id VARCHAR(64) NOT NULL, weather JSON NULL, last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP);
~~~~~~~

Вывод в случае успеха должен быть `Query OK`, но вы можете проверить, что таблица действительно создавалась, запустив `mysql> SHOW TABLES;`. Выйдите из контейнера и MySQL CLI, набрав `\q`.

### Что здесь происходит?

В отличие от прошлого раза, когда мы вошли в командную строку MySQL, на этот раз мы сократили процесс до всего лишь одного шага. Помните, что при выполнении `docker run` или` docker exec` последняя часть — это команда, которую мы хотим выполнить в контейнере. Это означает, что нам фактически не нужно начинать сессию bash, а затем входить в MySQL, мы можем просто напрямую войти в CLI базы данных.

Это можно сделать с помощью любой команды, доступной в контейнере, поэтому `docker exec` становится крайне полезной для просмотра того, что происходит в ваших контейнерах.

## Сохранение в базе данных из нашего PHP-приложения

Теперь, когда наша база данных готова к хранению данных о погоде, и она сохранит эти данные даже после удаления контейнера, нам необходимо обновить наше приложение PHP для подключения и сохранения результатов погоды в базе данных.

Первоначально файл `index.php` получал данные непосредственно из API MetaWeather, но теперь, когда у нас есть механизм хранения (т.е. наша база данных), давайте реализуем в приложении возможность сохранять данные в базе данных при повторных запросов.

{title="index.php", linenos=off, lang=php}
~~~~~~~
<?php

require 'vendor/autoload.php';

// Создать контейнер
$container = new \Slim\Container([
    // Добавить в контейнер Guzzle под идентификатором 'http'
    'http' => function () {
        return new GuzzleHttp\Client();
    },
    // Добавить в контейнер mysqli под идентификатором 'mysql'
    'mysql' => function () {
        $mysqli = new mysqli(
            "weather-db",
            "admin",
            "p23l%v11p",
            "weather"
        );
        if ($mysqli->connect_errno) {
            echo "Не удалось подключиться к MySQL: " . $mysqli->connect_error;
            exit;
        } else {
            return $mysqli;
        }
    },
]);
// Создать объект App
$app = new \Slim\App($container);

// Получить погоду по идентификатору местоположения
$app->get('/locations/{id}', function ($request, $response, $args) {
    // Получить местоположение из базы данных
    $id = $this->mysql->real_escape_string($args['id']);
    $results = $this->mysql->query("SELECT * FROM locations WHERE id='{$id}'");

    // Если местоположение найдено, тогда получить прогноз погоды из БД, в противном случае сделать запрос к MetaWeather
    if ($results->num_rows > 0) {
        $result = $results->fetch_assoc()['weather'];
    } else {
        $result = $this->http->get("https://www.metaweather.com/api/location/{$id}")
            ->getBody()
            ->getContents();
        $cleanResult = $this->mysql->real_escape_string($result);
        if (!$this->mysql->query("INSERT into locations (id, weather) VALUES ('{$id}', '{$cleanResult}')")) {
            throw new Exception("Местоположение не может быть обновлено.");
        }
    }

    // Возвратить результаты в формате JSON
    return $response->withStatus(200)->withJson(json_decode($result));
});

// Запуск приложения
$app->run();
~~~~~~~

### Что здесь происходит?

Только что мы добавили два важных изменения в наш файл `index.php`. Сначала мы обновили переменную `$container`:

{title="index.php", linenos=off, lang=php}
~~~~~~~
$container = new \Slim\Container([
    // Добавить в контейнер Guzzle под идентификатором 'http'
    'http' => function () {
        return new GuzzleHttp\Client();
    },
    // Добавить в контейнер mysqli под идентификатором 'mysql'
    'mysql' => function () {
        $mysqli = new mysqli(
            "weather-db",   // Хост базы данных
            "admin",        // Пользователь базы данных
            "p23l%v11p",    // Пароль базы данных
            "weather"       // Имя базы данных
        );
        if ($mysqli->connect_errno) {
            echo "Не удалось подключиться к MySQL: " . $mysqli->connect_error;
            exit;
        } else {
            return $mysqli;
        }
    },
]);
~~~~~~~

Guzzle остался таким же, но мы добавили элемент с именем `mysql` в массив. Этот колбэк создаёт [MySQLi](http://php.net/manual/ru/book.mysqli.php) с жёстко заданными учётными данными базы данных.

> Жёстко заданные учётные данные вашей базы данных, как это сделано в примере выше — плохая идея в реальном приложении. Мы рассмотрим более безопасный способ включения учётных данных через переменные окружения в Docker в последнем разделе этой главы. Пока же не делайте коммит с такими изменениями в публичном репозитории, если вы не планируете менять свой пароль базы данных.

Другим большим обновлением файла является конечная точка `GET /locations`:

{title="index.php", linenos=off, lang=php}
~~~~~~~
$app->get('/locations/{id}', function ($request, $response, $args) {
    // Получить местоположение из базы данных
    $id = $this->mysql->real_escape_string($args['id']);
    $results = $this->mysql->query("SELECT * FROM locations WHERE id='{$id}'");

    // Если местоположение найдено, тогда получить прогноз погоды из БД, в противном случае сделать запрос к MetaWeather
    if ($results->num_rows > 0) {
        $result = $results->fetch_assoc()['weather'];
    } else {
        $result = $this->http->get("https://www.metaweather.com/api/location/{$id}")
            ->getBody()
            ->getContents();
        $cleanResult = $this->mysql->real_escape_string($result);
        if (!$this->mysql->query("INSERT into locations (id, weather) VALUES ('{$id}', '{$cleanResult}')")) {
            throw new Exception("Местоположение не может быть обновлено.");
        }
    }

    // Возвратить результаты в формате JSON
    return $response->withStatus(200)->withJson(json_decode($result));
});
~~~~~~~

Хотя комментарии в коде могут помочь, стоит несколько более подробно расписать, что происходит, в случае если вы не знакомы с MySQLi:

* `$id = $this->mysql->real_escape_string($args['id']);` — для начала мы экранируем значение элемента `id` массива `$args`, доступного в конечной точки. Это хорошая идея в любое время, когда вы принимаете пользовательский или сторонний ввод, поскольку он может случайно (или преднамеренно) вводить SQL-выражения, которые ломают ваш код.

* `$results = $this->mysql->query("SELECT * FROM locations WHERE id='{$id}'");` — хотя я обычно [использовал ORM](https://stackoverflow.com/a/1279678) для реального приложения, для такого простого примера с двумя конечными точками это, очевидно, было бы излишне. Поэтому мы используем [MySQLi — PHP-расширение для доступа к MySQL](http://php.net/manual/ru/book.mysqli.php) для выполнения запроса к базе данных. Это позволяет нам писать необработанный SQL-запрос с внедрёнными в него PHP-переменными.

* `if ($results->num_rows > 0) {...}` — если мы найдём хотя бы один результат для этого идентификатора местоположения, нам нужно вернуть результат из базы данных. Если нет, то мы переходим в альтернативную ветвь...

* `else { ... $this->mysql->query("INSERT into locations (id, weather) VALUES ('{$id}', '{$cleanResult}')") ...` — если мы не нашли результата по этому идентификатору местоположения в базе данных, то получаем его из API MetaWeather, экранируя JSON-строку, а затем вставляем результат в базу данных.

* `return $response->withStatus(200)->withJson(json_decode($result));` — как и раньше, мы возвращаем пользователю результат в формате JSON.

## Связывание контейнера PHP

С созданным кодом теперь нам нужно запустить новый контейнер PHP, связанный с контейнером базы данных MySQL, который мы только что начали:

{linenos=off, lang=sh}
~~~~~~~
$ docker run -d --rm --name=weather-app -p 38000:80 -v $(pwd):/var/www/html --link weather-db shiphp/weather-app
~~~~~~~

### Что здесь происходит?

В этой команде `docker run` есть две новые части:

* `--link weather-db` — это связывает контейнер с именем `weather-db` с этим контейнером. Вы также можете [предоставить связанному контейнеру псевдоним](https://docs.docker.com/engine/reference/run/#expose-incoming-ports) для использования внутри PHP-контейнера, но нам не понадобятся делать это здесь.

* `shiphp/weather-app` — вместо использования образа `php:apache`, который мы использовали в предыдущей главе, используем новый Docker-образ, которое мы собрали в начале этой главы. Причина этого в том, что нам нужно расширение PHP MySQLi, которое мы добавили в наш файл `Dockerfile`.

Теперь, когда наш PHP-контейнер запущен и работает, у вас есть возможность перейти к идентификатору местоположения, например:

`GET http://localhost:38000/index.php/locations/2487956`

При первой загрузке этого URL-адреса, вероятно, потребуется пара секунд, но если вы обновите страницу, то почувствуете значительно более быстрое получение результата. У меня загрузка заняла менее 150 мс! Это благодаря кешированию, которое мы просто реализовали, сохраняя результат в базе данных.

## Удаление данных

Для удаления данных из базы данных, мы добавим вторую конечную точку. Добавьте следующий код сразу после конечной точки `$app->get(...);`, чтобы пользователи могли удалять местоположение из базы данных:

#### index.php (частичный)

{title="index.php", linenos=off, lang=php}
~~~~~~~
$app->delete('/locations/{id}', function ($request, $response, $args) {
    // Получить местоположение из базы данных
    $id = $this->mysql->real_escape_string($args['id']);
    $results = $this->mysql->query("SELECT * FROM locations WHERE id='{$id}'");

    // Если существует, удалить местоположение, в противном случае отправить ответ с кодом состояния 404
    if (
        $results->num_rows > 0 &&
        $this->mysql->query("DELETE FROM locations WHERE id='{$id}'")
    ) {
        return $response->withStatus(200)->write("Удалено местоположение {$args['id']}.");
    } else {
        return $response->withStatus(404)->write("Местоположение {$args['id']} не найдено.");
    }
});

// Запуск приложения
$app->run();
~~~~~~~

Теперь вы можете использовать [cURL](https://www.garron.me/en/bits/curl-delete-request.html) или [Postman](https://www.getpostman.com/), чтобы выполнить запрос `DELETE` на ту же самую конечную точку местоположения, которую мы только что создали. Например:

`DELETE http://localhost:38000/index.php/locations/2487956`

Вы должны увидеть сообщение `Удалено местоположение 2487956` и теперь, когда вы снова сделаете запрос `GET` на этот URL, потребуется больше времени ожидания, поскольку результат должен прийти из API MetaWeather.

## Управление переменными окружения

Последняя тема, которую мы рассмотрим в этой главе, — это управление переменными окружения в Docker. Docker позволяет вам указывать переменные окружения во время выполнения, чтобы ваш PHP-код мог иметь доступ к этим переменным, но вам не придётся жёстко задавать их, как это было сделано выше.

Прежде всего нам нужно будет изменить код, определяющий наши учётные данные в файле `index.php`:

{title="index.php", linenos=off, lang=php}
~~~~~~~
// Создать контейнер
$container = new \Slim\Container([
    // Добавить в контейнер Guzzle под идентификатором 'http'
    'http' => function () {
        return new GuzzleHttp\Client();
    },
    // Добавить в контейнер mysqli под идентификатором 'mysql'
    'mysql' => function () {
        $mysqli = new mysqli(
            getenv('DATABASE_HOST'),
            getenv('DATABASE_USER'),
            getenv('DATABASE_PASSWORD'),
            getenv('DATABASE_NAME')
        );
        if ($mysqli->connect_errno) {
            echo "Не удалось подключиться к MySQL: " . $mysqli->connect_error;
            exit;
        } else {
            return $mysqli;
        }
    },
]);
~~~~~~~

Остановите контейнер PHP и повторно запустите его с помощью следующей команды:

{linenos=off, lang=sh}
~~~~~~~
$ docker run -d --rm --name=weather-app -p 38000:80 -v $(pwd):/var/www/html --link weather-db -e DATABASE_HOST='weather-db' -e DATABASE_USER='admin' -e DATABASE_PASSWORD='p23l%v11p' -e DATABASE_NAME='weather' shiphp/weather-app
~~~~~~~

Теперь вы можете безопасно делиться своим PHP-кодом, не раскрывая учётные данные для входа в базу данных.

### Что здесь происходит?

PHP может считывать переменные окружения из операционной системы [используя функцию getenv](http://php.net/manual/ru/function.getenv.php), и когда мы используем эту функцию в контейнере, результат тот же самый. Вместо чтения переменных окружения из операционной системы хоста (например, вашего компьютера), он считывает переменные окружения из контейнера Docker, на котором запущен код. Это способствует безопасности, потому что разные контейнеры не используют переменные среды, и это помогает упростить обмен кода.

Обновлённая команда `docker run` теперь включает в себя четыре флага `-e`, которые преобразуются в переменные окружения в контейнере. Теперь ваше PHP-приложение будет считывать переменные среды, которые вы устанавливаете при запуске контейнера вместо жёстко заданных значений или значений с вашего хост-машины.

> Если вы не хотите вводить длинные команды, похожие на указанные выше, каждый раз, когда вы запускаете свой контейнер, вы можете использовать Docker Compose и/или файл `.env`. Это описано в [этом gjcnt в блоге](https://www.shiphp.com/blog/2017/env-php-docker).

Наконец, вы можете увидеть переменные среды, которые использует ваш контейнер, используя команду ниже:

{linenos=off, lang=sh}
~~~~~~~
$ docker inspect weather-app
~~~~~~~

Возвращённый JSON из этой команды даст вам много информации о запущенном контейнере, но для этого примера нам нужен только информация в массиве `Config.Env`:

{linenos=off, lang=php}
~~~~~~~
[
    "DATABASE_HOST=weather-app",
    "DATABASE_USER=admin",
    "DATABASE_PASSWORD=p23l%v11p",
    "DATABASE_NAME=weather",
    // ...
],

//...
~~~~~~~

Если все работает правильно, теперь у вас есть доступ к приложению, как и раньше. В следующей главе мы быстро рассмотрим, как мы можем улучшить это приложение, используя продвинутые темы Docker. Если вы хотите взглянуть на полный исходный код этого приложения, то вы можете найти его [на GitHub](https://github.com/shiphp/weather-app).